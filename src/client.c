#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>

#include "pad.h"
#include "rsa.h"
#include "crypto.h"

#define FAIL 2

// Print a BIGNUM struct
void bn_print(BIGNUM *bn) {
  char* debug;
  debug = BN_bn2dec(bn);
  printf("%s\n", debug);

  OPENSSL_free(debug);
}


/**
 * Read a message over the network from the client (in chunks since I assume
 * BIGNUM is a large struct). Then, decrypt the enciphered message they sent
 * (encrypted using OUR public key) using our private key. Resulting message
 * is stored in plaintext.
 *
 * @param server_socket - the socket_fd for communicating with the client
 * @param plaintext - location to save the resulting plain text string to
 * @param priv_key - the private key generated by message receiver. For decrypting
 *                    the message
 */
void get_message(int server_socket, char **plaintext, key_pair_t *priv_key) {
  // read message sent from client (it's an encrypted BIGNUM struct)
  BIGNUM *message = BN_new();
  int total_bytes_read = 0;
  do {
    int bytes_read = read(server_socket,
                          message + total_bytes_read,
                          sizeof(BIGNUM) - total_bytes_read);
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(BIGNUM));

  // decrypt to string
  decrypt_str(plaintext, message, priv_key);
  BN_free(message);
}

/**
 * Send a message over the network to the client (implicitly writes in chunks
 * if large enough message size). Then, encrypt plaintext message input by user
 * using THEIR public key so they can decrypt it.
 *
 * @param server_socket - the socket_fd for communicating with the client
 * @param plaintext - plain text string to encrypt and then send over network
 * @param priv_key - the public key generated by message receiver. For encrypting
 *                    the message
 */
void send_message(int server_socket, char *plaintext, key_pair_t *their_pub_key) {
  BIGNUM *cipher_text = BN_new();
  // encrypt message
  encrypt_str(cipher_text, plaintext, their_pub_key);

  // interact with client by echoing re-encrypted message back to them
  write(server_socket, cipher_text, sizeof(BIGNUM));
  BN_free(cipher_text);
}


/**
 * Public key cryptography; exchange public keys with other machine (they don't
 * need to be sent securely since they are useless without the private key, which
 * is kept secret and is NEVER sent over the network). Knowing our recipient's
 * public key and them knowing ours allows the machines to communicate securely.
 *
 * Notice read/write order is reversed from server version. Wouldn't want to
 * deadlock on each waiting to hear from each other first.
 *
 * @param their_pub_key - the struct to save the key read over network into
 * @param my_pub_key - the key to send over the network to the client
 * @param server_socket - the socket_fd to send/read the keys to/from
 */
void crypto_handshake(key_pair_t *their_pub_key, key_pair_t *my_pub_key, int server_socket) {
  // send them our public key
  write(server_socket, my_pub_key, sizeof(key_pair_t));

  // read in their public key (by chunks if necessary..)
  int total_bytes_read = 0;
  do {
    int bytes_read = read(server_socket,
                          their_pub_key + total_bytes_read,
                          sizeof(key_pair_t) - total_bytes_read);

    if(bytes_read < 0) break;
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(key_pair_t));
}

/*
 * A simple client program to connect via TCP/IC to a host server
 * - takes a host name in command line args
 */
int main(int argc, char** argv) {
  if(argc < 3) {
    printf("Usage: ./%s <SERVER_HOST_NAME> <PORT_NUMBER>\n", argv[0]);
    printf("Try 'localhost' if you are running server.c on the same computer.\n");
    exit(0);
  }

  // get RSA encryption keys
  key_pair_t *pub = malloc(sizeof(key_pair_t));
  key_pair_t *priv = malloc(sizeof(key_pair_t));
  get_keys(pub, priv);

  //get host name from command line and convert to IP addr
  struct hostent* server = gethostbyname(argv[1]);
  if(server == NULL) {
    //no actual error occurred, so fprintf to stderr
    fprintf(stderr, "Unable to find host %s", argv[1]);
    exit(1);
  }

  //set up socket to server
  int server_socket = socket(AF_INET, SOCK_STREAM, 0);
  if(server_socket == -1) {
    perror("socket failed: ");
    exit(FAIL);
  }

  //init socket address info
  unsigned short port = (unsigned short) atoi(argv[2]);
  struct sockaddr_in addr = {
    .sin_family = AF_INET,
    .sin_port = htons(port)
  };

  //fill host address into server variable
  //copy bytes from server to addr
  bcopy((char*)server->h_addr, (char*)&addr.sin_addr.s_addr, server->h_length);

  //connect to the server
  if(connect(server_socket, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))) {
    perror("connect failed: ");
    exit(FAIL);
  }

  // do handshake
  key_pair_t *their_pub_key = malloc(sizeof(key_pair_t));
  crypto_handshake(their_pub_key, pub, server_socket);

  // infinitely communicate with server
  printf("You are now connected with the server!\nPress '^C' to exit program\n");
  while(1) {
    //get a message
    const int size = 256;
    char msg[size];
    printf("Enter a message to send to the server:\n");
    fgets(msg, size, stdin);

    //send message to server
    send_message(server_socket, msg, their_pub_key);

    //read data sent from server
    char *return_msg;
    get_message(server_socket, &return_msg, priv);

    printf("Server sent message: %s\n", return_msg);
  }

  //clean up open sockets
  close(server_socket);
  free(their_pub_key);

  return 0;
}
