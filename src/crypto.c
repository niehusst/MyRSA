/*
 * A small collection of functions that will be useful for "secure"
 * (my implementation probably isn't professional quality) encryption.
 */
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <openssl/bn.h>

#include "pad.h"
#include "rsa.h"
#include "crypto.h"


/**
 * Encrypt the data in the string msg using pub_key as the encryption key.
 *
 * @param cipher_text - the struct to store the resulting encipherment in
 * @param msg - the message to encrypt
 * @param pub_key - the key to use to encrypt msg
 * @return status - function error status, 1 on failure, 0 on success
 */
int encrypt_str(BIGNUM* cipher_text, const char* msg, const key_pair_t* pub_key) {
  int status = 0;
  BN_CTX *ctx = BN_CTX_new();

  // pad msg
  if(text_to_num(cipher_text, msg)) {
    fprintf(stderr, "%s\n", "Message padding failed");
    status = 1;
  }

  // encrypt
  if(!BN_mod_exp(cipher_text, cipher_text, pub_key->power, pub_key->mod, ctx)) {
    fprintf(stderr, "%s\n", "Message encryption failed");
    status = 1;
  }

  BN_CTX_free(ctx);
  return status;
}

/**
 * Dencrypt the data in cipher_text using priv_key as the encryption key.
 *
 * @param msg - the location to store the decrypted clear text
 * @param cipher_text - the enciphered data to decrypt
 * @param priv_key - the key to use to dencrypt cipher_text
 * @return status - function error status, 1 on failure, 0 on success
 */
int decrypt_str(char** msg, const BIGNUM* cipher_text, const key_pair_t* priv_key) {
  int status = 0;
  BN_CTX *ctx = BN_CTX_new();
  BIGNUM *ct = BN_dup(cipher_text);

  // decrypt
  if(!BN_mod_exp(ct, cipher_text, priv_key->power, priv_key->mod, ctx)) {
    fprintf(stderr, "%s\n", "Message decryption failed");
    status = 1;
  }

  // unpad msg
  if(num_to_text(msg, ct)) {
    fprintf(stderr, "%s\n", "Message unpadding failed");
    status = 1;
  }

  BN_CTX_free(ctx);
  return status;
}


// Print a BIGNUM struct
void bn_print(BIGNUM *bn) {
  char* debug;
  debug = BN_bn2dec(bn);
  printf("%s\n", debug);

  OPENSSL_free(debug);
}


/**
 * Read a message over the network from the client (in chunks since I assume
 * BIGNUM is a large struct). Then, decrypt the enciphered message they sent
 * (encrypted using OUR public key) using our private key. Resulting message
 * is stored in plaintext.
 *
 * @param server_socket - the socket_fd for communicating with the client
 * @param plaintext - location to save the resulting plain text string to
 * @param priv_key - the private key generated by message receiver. For decrypting
 *                    the message
 */
void get_encrypted_message(int socket, char **plaintext, key_pair_t *priv_key) {
  // read message sent from client (it's an encrypted BIGNUM struct)
  BIGNUM *message = BN_new();
  int total_bytes_read = 0;
  do {
    int bytes_read = read(socket,
                          message + total_bytes_read,
                          sizeof(BIGNUM) - total_bytes_read);
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(BIGNUM));

  // decrypt to string
  decrypt_str(plaintext, message, priv_key);
  BN_free(message);
}

/**
 * Send a message over the network to the client (implicitly writes in chunks
 * if large enough message size). Then, encrypt plaintext message input by user
 * using THEIR public key so they can decrypt it.
 *
 * @param server_socket - the socket_fd for communicating with the client
 * @param plaintext - plain text string to encrypt and then send over network
 * @param priv_key - the public key generated by message receiver. For encrypting
 *                    the message
 */
void send_encrypted_message(int socket, char *plaintext, key_pair_t *their_pub_key) {
  BIGNUM *cipher_text = BN_new();
  // encrypt message
  encrypt_str(cipher_text, plaintext, their_pub_key);

  // interact with client by echoing re-encrypted message back to them
  write(socket, cipher_text, sizeof(BIGNUM));
  BN_free(cipher_text);
}


/**
 * Public key cryptography; exchange public keys with other machine (they don't
 * need to be sent securely since they are useless without the private key, which
 * is kept secret and is NEVER sent over the network). Knowing our recipient's
 * public key and them knowing ours allows the machines to communicate securely.
 *
 * Notice read/write order is reversed from server version. Wouldn't want to
 * deadlock on each waiting to hear from each other first.
 *
 * @param their_pub_key - the struct to save the key read over network into
 * @param my_pub_key - the key to send over the network to the client
 * @param server_socket - the socket_fd to send/read the keys to/from
 */
void crypto_handshake_with_server(key_pair_t *their_pub_key,
                                  key_pair_t *my_pub_key,
                                  int server_socket) {
  // send them our public key
  write(server_socket, my_pub_key, sizeof(key_pair_t));

  // read in their public key (by chunks if necessary..)
  int total_bytes_read = 0;
  do {
    int bytes_read = read(server_socket,
                          their_pub_key + total_bytes_read,
                          sizeof(key_pair_t) - total_bytes_read);

    if(bytes_read < 0) break;
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(key_pair_t));
}

/**
 * Public key cryptography; exchange public keys with other machine (they don't
 * need to be sent securely since they are useless without the private key, which
 * is kept secret and is NEVER sent over the network). Knowing our recipient's
 * public key and them knowing ours allows the machines to communicate securely.
 *
 * @param their_pub_key - the struct to save the key read over network into
 * @param my_pub_key - the key to send over the network to the client
 * @param client_socket - the socket_fd to send/read the keys to/from
 */
void crypto_handshake_with_client(key_pair_t *their_pub_key,
                                  key_pair_t *my_pub_key,
                                  int client_socket) {
  // read in their public key (by chunks if necessary..)
  int total_bytes_read = 0;
  do {
    int bytes_read = read(client_socket,
                          their_pub_key + total_bytes_read,
                          sizeof(key_pair_t) - total_bytes_read);

    if(bytes_read < 0) break;
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(key_pair_t));

  // send them our public key
  write(client_socket, my_pub_key, sizeof(key_pair_t));
}
