/*
 * A small collection of functions that will be useful for "secure"
 * (my implementation probably isn't professional quality) encryption.
 */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <openssl/bn.h>

#include "pad.h"
#include "rsa.h"
#include "crypto.h"


/**
 * Encrypt the data in the string msg using pub_key as the encryption key.
 *
 * @param cipher_text - the struct to store the resulting encipherment in
 * @param msg - the message to encrypt
 * @param pub_key - the key to use to encrypt msg
 * @return status - function error status, 1 on failure, 0 on success
 */
int encrypt_str(BIGNUM* cipher_text, const char* msg, const key_pair_t* pub_key) {
  int status = 0;
  BN_CTX *ctx = BN_CTX_new();
  BIGNUM *temp = BN_new();
  printf("%s\n", "encrypting messge"); //DEBUG
  // pad msg
  if(text_to_num(temp, msg)) {
    fprintf(stderr, "%s\n", "Message padding failed");
    status = 1;
  }
  printf("%s\n", "converted to num"); //DEBUG
  if(pub_key == NULL) printf("%s\n", "pub key is null"); //DEBUG
  if(temp == NULL) printf("%s\n", "cihper is null"); //DEBUG
  if(pub_key->power == NULL) printf("%s\n", "power is nul"); //DEBUG
  if(pub_key->mod == NULL) printf("%s\n", "mod is null"); //DEBUG
  bn_print(temp);
  bn_print(pub_key->power);
  bn_print(pub_key->mod);
  printf("%s\n", "null checks done"); //DEBUG
  // encrypt
  if(!BN_mod_exp(cipher_text, temp, pub_key->power, pub_key->mod, ctx)) {
    fprintf(stderr, "%s\n", "Message encryption failed");
    status = 1;
  }
  printf("%s\n", "encrypted"); //DEBUG
  BN_CTX_free(ctx);
  BN_free(temp);
  return status;
}

/**
 * Dencrypt the data in cipher_text using priv_key as the encryption key.
 *
 * @param msg - the location to store the decrypted clear text
 * @param cipher_text - the enciphered data to decrypt
 * @param priv_key - the key to use to dencrypt cipher_text
 * @return status - function error status, 1 on failure, 0 on success
 */
int decrypt_str(char** msg, const BIGNUM* cipher_text, const key_pair_t* priv_key) {
  int status = 0;
  BN_CTX *ctx = BN_CTX_new();
  BIGNUM *ct = BN_dup(cipher_text);

  // decrypt
  if(!BN_mod_exp(ct, cipher_text, priv_key->power, priv_key->mod, ctx)) {
    fprintf(stderr, "%s\n", "Message decryption failed");
    status = 1;
  }

  // unpad msg
  if(num_to_text(msg, ct)) {
    fprintf(stderr, "%s\n", "Message unpadding failed");
    status = 1;
  }

  BN_CTX_free(ctx);
  return status;
}


// Print a BIGNUM struct
void bn_print(BIGNUM *bn) {
  char* debug;
  debug = BN_bn2dec(bn);
  printf("%s\n", debug);

  OPENSSL_free(debug);
}


/**
 * Read a message over the network from the client (in chunks since I assume
 * BIGNUM is a large struct). Then, decrypt the enciphered message they sent
 * (encrypted using OUR public key) using our private key. Resulting message
 * is stored in plaintext.
 *
 * @param server_socket - the socket_fd for communicating with the client
 * @param plaintext - location to save the resulting plain text string to
 * @param priv_key - the private key generated by message receiver. For decrypting
 *                    the message
 */
void get_encrypted_message(int socket, char **plaintext, key_pair_t *priv_key) {
  // read message sent from client (it's an encrypted BIGNUM struct)
  BIGNUM *message = BN_new();
  int total_bytes_read = 0;
  do {
    int bytes_read = read(socket,
                          message + total_bytes_read,
                          sizeof(BIGNUM) - total_bytes_read);
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(BIGNUM));

  // decrypt to string
  decrypt_str(plaintext, message, priv_key);
  BN_free(message);
}

/**
 * Send a message over the network to the client (implicitly writes in chunks
 * if large enough message size). Then, encrypt plaintext message input by user
 * using THEIR public key so they can decrypt it.
 *
 * @param server_socket - the socket_fd for communicating with the client
 * @param plaintext - plain text string to encrypt and then send over network
 * @param priv_key - the public key generated by message receiver. For encrypting
 *                    the message
 */
void send_encrypted_message(int socket, char *plaintext, key_pair_t *their_pub_key) {
  BIGNUM *cipher_text = BN_new();
  // encrypt message
  encrypt_str(cipher_text, plaintext, their_pub_key);

  // interact with client by echoing re-encrypted message back to them
  write(socket, cipher_text, sizeof(BIGNUM));
  BN_free(cipher_text);
}


/**
 * Public key cryptography; exchange public keys with other machine (they don't
 * need to be sent securely since they are useless without the private key, which
 * is kept secret and is NEVER sent over the network). Knowing our recipient's
 * public key and them knowing ours allows the machines to communicate securely.
 *
 * Notice read/write order is reversed from server version. Wouldn't want to
 * deadlock on each waiting to hear from each other first.
 *
 * @param their_pub_key - the struct to save the key read over network into
 * @param my_pub_key - the key to send over the network to the client
 * @param server_socket - the socket_fd to send/read the keys to/from
 * @return int - error status; 1 on failure, 0 on success
 */
int crypto_handshake_with_server(key_pair_t *their_pub_key,
                                  key_pair_t *my_pub_key,
                                  int server_socket) {
  // send them our public key
  // convert power and mod fields to str, then send them strs, which can be
  // converted back into BIGNUM fields
  char *power, *mod;
  power = BN_bn2dec(my_pub_key->power);
  mod = BN_bn2dec(my_pub_key->mod);
  int ps = strlen(power), ms = strlen(mod);
  printf("pow size %d and mod size %d\n", ps, ms);
  write(server_socket, &ps, sizeof(int));
  write(server_socket, &ms, sizeof(int));
  write(server_socket, power, sizeof(char)*strlen(power));
  write(server_socket, mod, sizeof(char)*strlen(mod));
  OPENSSL_free(power);
  OPENSSL_free(mod);

  // get size of power and mod strings
  int pow_size = 0, mod_size = 0;
  int total_bytes_read = 0;
  do {
    int br = read(server_socket, &pow_size, sizeof(int)-total_bytes_read);
    total_bytes_read += br;
  } while(total_bytes_read < sizeof(int));
  total_bytes_read = 0;
  do {
    int br = read(server_socket, &mod_size, sizeof(int)-total_bytes_read);
    total_bytes_read += br;
  } while(total_bytes_read < sizeof(int));
  printf("pow size %d and mod size %d\n", pow_size, mod_size);

  // read power string over network
  char *pow_str = malloc(sizeof(char)*pow_size);
  total_bytes_read = 0;
  do {
    int bytes_read = read(server_socket,
                          pow_str + total_bytes_read,
                          pow_size - total_bytes_read);
    printf("read bytes: %d out of %d\n", bytes_read, (pow_size-total_bytes_read));//DEBUG
    if(bytes_read < 0) {
      fprintf(stderr, "%s\n", "Reading key from server failed");
      return 1;
    }
    total_bytes_read += bytes_read;
  } while(total_bytes_read < pow_size);
  // write to key parameter
  their_pub_key->power = BN_new();
  BN_dec2bn(&their_pub_key->power, pow_str);
  free(pow_str);

  // read in the mod string over the network
  char *mod_str = malloc(sizeof(char)*mod_size);
  total_bytes_read = 0;
  do {
    int bytes_read = read(server_socket,
                          mod_str + total_bytes_read,
                          mod_size - total_bytes_read);
    printf("read bytes: %d out of %d\n", bytes_read, (mod_size-total_bytes_read));//DEBUG
    if(bytes_read < 0) {
      fprintf(stderr, "%s\n", "Reading key from server failed");
      return 1;
    }
    total_bytes_read += bytes_read;
  } while(total_bytes_read < mod_size);
  // write to key parameter
  their_pub_key->mod = BN_new();
  BN_dec2bn(&their_pub_key->mod, mod_str);
  free(mod_str);

  return 0;
}

/**
 * Public key cryptography; exchange public keys with other machine (they don't
 * need to be sent securely since they are useless without the private key, which
 * is kept secret and is NEVER sent over the network). Knowing our recipient's
 * public key and them knowing ours allows the machines to communicate securely.
 *
 * @param their_pub_key - the struct to save the key read over network into
 * @param my_pub_key - the key to send over the network to the client
 * @param client_socket - the socket_fd to send/read the keys to/from
 * @return int - error status; 1 on failure, 0 on success
 */
int crypto_handshake_with_client(key_pair_t *their_pub_key,
                                  key_pair_t *my_pub_key,
                                  int client_socket) {
  // get size of power and mod strings
  int pow_size = 0, mod_size = 0;
  int total_bytes_read = 0;
  do {
    int br = read(client_socket, &pow_size, sizeof(int)-total_bytes_read);
    total_bytes_read += br;
  } while(total_bytes_read < sizeof(int));
  total_bytes_read = 0;
  do {
    int br = read(client_socket, &mod_size, sizeof(int)-total_bytes_read);
    total_bytes_read += br;
  } while(total_bytes_read < sizeof(int));

  // read power string over network
  char *pow_str = malloc(sizeof(char)*pow_size);
  total_bytes_read = 0;
  do {
    int bytes_read = read(client_socket,
                          pow_str + total_bytes_read,
                          pow_size - total_bytes_read);
    printf("read bytes: %d out of %d\n", bytes_read, (pow_size-total_bytes_read));//DEBUG
    if(bytes_read < 0) {
      fprintf(stderr, "%s\n", "Reading key from client failed");
      return 1;
    }
    total_bytes_read += bytes_read;
  } while(total_bytes_read < pow_size);
  // write to key parameter
  their_pub_key->power = BN_new();
  BN_dec2bn(&their_pub_key->power, pow_str);
  free(pow_str);

  // read in the mod string over the network
  char *mod_str = malloc(sizeof(char)*mod_size);
  total_bytes_read = 0;
  do {
    int bytes_read = read(client_socket,
                          mod_str + total_bytes_read,
                          mod_size - total_bytes_read);
    printf("read bytes: %d out of %d\n", bytes_read, (mod_size-total_bytes_read));//DEBUG
    if(bytes_read < 0) {
      fprintf(stderr, "%s\n", "Reading key from client failed");
      return 1;
    }
    total_bytes_read += bytes_read;
  } while(total_bytes_read < mod_size);
  // write to key parameter
  their_pub_key->mod = BN_new();
  BN_dec2bn(&their_pub_key->mod, mod_str);
  free(mod_str);

  // send them our public key
  // convert power and mod fields to str, then send them strs, which can be
  // converted back into BIGNUM fields
  char *power, *mod;
  power = BN_bn2dec(my_pub_key->power);
  mod = BN_bn2dec(my_pub_key->mod);
  int ps = strlen(power), ms = strlen(mod);
  printf("pow size %d and mod size %d\n", ps, ms);
  write(client_socket, &ps, sizeof(int));
  write(client_socket, &ms, sizeof(int));
  write(client_socket, power, sizeof(char)*strlen(power));
  write(client_socket, mod, sizeof(char)*strlen(mod));
  OPENSSL_free(power);
  OPENSSL_free(mod);

  return 0;
}
