#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <openssl/bn.h>

#include "rsa.h"
#include "crypto.h"

#define FAIL 2


// Print a BIGNUM struct
void bn_print(BIGNUM *bn) {
  char* debug;
  debug = BN_bn2dec(bn);
  printf("%s\n", debug);

  OPENSSL_free(debug);
}


/**
 * Read a message over the network from the client (in chunks since I assume
 * BIGNUM is a large struct). Then, decrypt the enciphered message they sent
 * (encrypted using OUR public key) using our private key. Resulting message
 * is stored in plaintext.
 *
 * @param client_socket - the socket_fd for communicating with the client
 * @param plaintext - location to save the resulting plain text string to
 * @param priv_key - the private key generated by message receiver. For decrypting
 *                    the message
 */
void get_message(int client_socket, char **plaintext, key_pair_t *priv_key) {
  // read message sent from client (it's an encrypted BIGNUM struct)
  BIGNUM *message = BN_new();
  int total_bytes_read = 0;
  do {
    int bytes_read = read(client_socket,
                          message + total_bytes_read,
                          sizeof(BIGNUM) - total_bytes_read);
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(BIGNUM));

  // decrypt to string
  decrypt_str(plaintext, message, priv_key);
  BN_free(message);
}

/**
 * Send a message over the network to the client (implicitly writes in chunks
 * if large enough message size). Then, encrypt plaintext message input by user
 * using THEIR public key so they can decrypt it.
 *
 * @param client_socket - the socket_fd for communicating with the client
 * @param plaintext - plain text string to encrypt and then send over network
 * @param priv_key - the public key generated by message receiver. For encrypting
 *                    the message
 */
void send_message(int client_socket, char *plaintext, key_pair_t *their_pub_key) {
  BIGNUM *cipher_text = BN_new();
  // encrypt message
  encrypt_str(cipher_text, plaintext, their_pub_key);

  // interact with client by echoing re-encrypted message back to them
  write(client_socket, cipher_text, sizeof(BIGNUM));
  BN_free(cipher_text);
}


/**
 * Public key cryptography; exchange public keys with other machine (they don't
 * need to be sent securely since they are useless without the private key, which
 * is kept secret and is NEVER sent over the network). Knowing our recipient's
 * public key and them knowing ours allows the machines to communicate securely.
 *
 * @param their_pub_key - the struct to save the key read over network into
 * @param my_pub_key - the key to send over the network to the client
 * @param client_socket - the socket_fd to send/read the keys to/from
 */
void crypto_handshake(key_pair_t *their_pub_key, key_pair_t *my_pub_key, int client_socket) {
  // read in their public key (by chunks if necessary..)
  int total_bytes_read = 0;
  do {
    int bytes_read = read(client_socket,
                          their_pub_key + total_bytes_read,
                          sizeof(key_pair_t) - total_bytes_read);

    if(bytes_read < 0) break;
    total_bytes_read += bytes_read;
  } while(total_bytes_read < sizeof(key_pair_t));

  // send them our public key
  write(client_socket, my_pub_key, sizeof(key_pair_t));
}


/*
 * A simple TCP/IP echo server using RSA encryption to make sure what you're
 * sending yourself isn't seen by any eavesdroppers.
 * Optionally, a port number can be given as a command line argument. If
 * port number isn't specified, the OS chooses.
 *
 * (to test; run the server executable and then in a separate window,
 * `nc localhost 4444` to get test server functionality)
 */
int main(int argc, char** argv) {
  // get RSA encryption keys
  key_pair_t *pub = malloc(sizeof(key_pair_t));
  key_pair_t *priv = malloc(sizeof(key_pair_t));
  get_keys(pub, priv);

  //get socket file descriptor
  int s = socket(AF_INET, SOCK_STREAM, 0);
  if(s == -1) {
    perror("Socket failed: ");
    exit(FAIL);
  }

  //init internet socket address
  unsigned short port;
  //
  port = argc==2 ? (unsigned short)atoi(argv[1]) : 0;
  struct sockaddr_in addr = {
    .sin_addr.s_addr = INADDR_ANY,
    .sin_family = AF_INET,
    .sin_port = htons(port) //OS chooses arbitrary open port number to listen at
  };

  //bind the sock addr to file descriptor
  if(bind(s, (struct sockaddr*)&addr, sizeof(struct sockaddr_in))) {
    perror("Binding socket failed: ");
    exit(FAIL);
  }

  //get socket info so client can connect
  socklen_t server_addr_len = sizeof(struct sockaddr_in);
  if(getsockname(s, (struct sockaddr*)&addr, &server_addr_len)) {
    close(s);
    exit(FAIL);
  }
  port = ntohs(addr.sin_port);
  printf("Sever is listening on port: %d\n", port);

  //tell socket to listen at port number
  if(listen(s, 2)) { //up to 2 connections at a time to this port
    perror("Listen failed: ");
    exit(FAIL);
  }

  //accept a incoming connection heard by listen
  struct sockaddr_in client_addr;
  socklen_t client_addr_length = sizeof(struct sockaddr_in);
  int client_socket = accept(s, (struct sockaddr*)&client_addr, &client_addr_length);
  if(client_socket == -1) {
    perror("Accept failed: ");
    exit(FAIL);
  }

  // exchange keys with client
  key_pair_t *their_pub_key = malloc(sizeof(key_pair_t));
  crypto_handshake(their_pub_key, pub, client_socket);

  // communicate infinitely with them (break on client program exit)
  while(1) {
    char *msg = NULL; //DEBUG this prob causes problesm
    get_message(client_socket, &msg, priv);

    send_message(client_socket, msg, their_pub_key);
  }

  //clean up server
  close(client_socket);
  close(s);
  free(their_pub_key);

  return 0;
}
